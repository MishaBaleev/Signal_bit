{"ast":null,"code":"import window from 'global/window'; // const log2 = Math.log2 ? Math.log2 : (x) => (Math.log(x) / Math.log(2));\n\nvar repeat = function repeat(str, len) {\n  var acc = '';\n  while (len--) {\n    acc += str;\n  }\n  return acc;\n}; // count the number of bits it would take to represent a number\n// we used to do this with log2 but BigInt does not support builtin math\n// Math.ceil(log2(x));\n\nexport var countBits = function countBits(x) {\n  return x.toString(2).length;\n}; // count the number of whole bytes it would take to represent a number\n\nexport var countBytes = function countBytes(x) {\n  return Math.ceil(countBits(x) / 8);\n};\nexport var padStart = function padStart(b, len, str) {\n  if (str === void 0) {\n    str = ' ';\n  }\n  return (repeat(str, len) + b.toString()).slice(-len);\n};\nexport var isArrayBufferView = function isArrayBufferView(obj) {\n  if (ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(obj);\n  }\n  return obj && obj.buffer instanceof ArrayBuffer;\n};\nexport var isTypedArray = function isTypedArray(obj) {\n  return isArrayBufferView(obj);\n};\nexport var toUint8 = function toUint8(bytes) {\n  if (bytes instanceof Uint8Array) {\n    return bytes;\n  }\n  if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {\n    // any non-number or NaN leads to empty uint8array\n    // eslint-disable-next-line\n    if (typeof bytes !== 'number' || typeof bytes === 'number' && bytes !== bytes) {\n      bytes = 0;\n    } else {\n      bytes = [bytes];\n    }\n  }\n  return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\n};\nexport var toHexString = function toHexString(bytes) {\n  bytes = toUint8(bytes);\n  var str = '';\n  for (var i = 0; i < bytes.length; i++) {\n    str += padStart(bytes[i].toString(16), 2, '0');\n  }\n  return str;\n};\nexport var toBinaryString = function toBinaryString(bytes) {\n  bytes = toUint8(bytes);\n  var str = '';\n  for (var i = 0; i < bytes.length; i++) {\n    str += padStart(bytes[i].toString(2), 8, '0');\n  }\n  return str;\n};\nvar BigInt = window.BigInt || Number;\nvar BYTE_TABLE = [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\nexport var ENDIANNESS = function () {\n  var a = new Uint16Array([0xFFCC]);\n  var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  if (b[0] === 0xFF) {\n    return 'big';\n  }\n  if (b[0] === 0xCC) {\n    return 'little';\n  }\n  return 'unknown';\n}();\nexport var IS_BIG_ENDIAN = ENDIANNESS === 'big';\nexport var IS_LITTLE_ENDIAN = ENDIANNESS === 'little';\nexport var bytesToNumber = function bytesToNumber(bytes, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$signed = _ref.signed,\n    signed = _ref$signed === void 0 ? false : _ref$signed,\n    _ref$le = _ref.le,\n    le = _ref$le === void 0 ? false : _ref$le;\n  bytes = toUint8(bytes);\n  var fn = le ? 'reduce' : 'reduceRight';\n  var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];\n  var number = obj.call(bytes, function (total, byte, i) {\n    var exponent = le ? i : Math.abs(i + 1 - bytes.length);\n    return total + BigInt(byte) * BYTE_TABLE[exponent];\n  }, BigInt(0));\n  if (signed) {\n    var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);\n    number = BigInt(number);\n    if (number > max) {\n      number -= max;\n      number -= max;\n      number -= BigInt(2);\n    }\n  }\n  return Number(number);\n};\nexport var numberToBytes = function numberToBytes(number, _temp2) {\n  var _ref2 = _temp2 === void 0 ? {} : _temp2,\n    _ref2$le = _ref2.le,\n    le = _ref2$le === void 0 ? false : _ref2$le;\n\n  // eslint-disable-next-line\n  if (typeof number !== 'bigint' && typeof number !== 'number' || typeof number === 'number' && number !== number) {\n    number = 0;\n  }\n  number = BigInt(number);\n  var byteCount = countBytes(number);\n  var bytes = new Uint8Array(new ArrayBuffer(byteCount));\n  for (var i = 0; i < byteCount; i++) {\n    var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);\n    bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(0xFF));\n    if (number < 0) {\n      bytes[byteIndex] = Math.abs(~bytes[byteIndex]);\n      bytes[byteIndex] -= i === 0 ? 1 : 2;\n    }\n  }\n  return bytes;\n};\nexport var bytesToString = function bytesToString(bytes) {\n  if (!bytes) {\n    return '';\n  } // TODO: should toUint8 handle cases where we only have 8 bytes\n  // but report more since this is a Uint16+ Array?\n\n  bytes = Array.prototype.slice.call(bytes);\n  var string = String.fromCharCode.apply(null, toUint8(bytes));\n  try {\n    return decodeURIComponent(escape(string));\n  } catch (e) {// if decodeURIComponent/escape fails, we are dealing with partial\n    // or full non string data. Just return the potentially garbled string.\n  }\n  return string;\n};\nexport var stringToBytes = function stringToBytes(string, stringIsBytes) {\n  if (typeof string !== 'string' && string && typeof string.toString === 'function') {\n    string = string.toString();\n  }\n  if (typeof string !== 'string') {\n    return new Uint8Array();\n  } // If the string already is bytes, we don't have to do this\n  // otherwise we do this so that we split multi length characters\n  // into individual bytes\n\n  if (!stringIsBytes) {\n    string = unescape(encodeURIComponent(string));\n  }\n  var view = new Uint8Array(string.length);\n  for (var i = 0; i < string.length; i++) {\n    view[i] = string.charCodeAt(i);\n  }\n  return view;\n};\nexport var concatTypedArrays = function concatTypedArrays() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n  buffers = buffers.filter(function (b) {\n    return b && (b.byteLength || b.length) && typeof b !== 'string';\n  });\n  if (buffers.length <= 1) {\n    // for 0 length we will return empty uint8\n    // for 1 length we return the first uint8\n    return toUint8(buffers[0]);\n  }\n  var totalLen = buffers.reduce(function (total, buf, i) {\n    return total + (buf.byteLength || buf.length);\n  }, 0);\n  var tempBuffer = new Uint8Array(totalLen);\n  var offset = 0;\n  buffers.forEach(function (buf) {\n    buf = toUint8(buf);\n    tempBuffer.set(buf, offset);\n    offset += buf.byteLength;\n  });\n  return tempBuffer;\n};\n/**\n * Check if the bytes \"b\" are contained within bytes \"a\".\n *\n * @param {Uint8Array|Array} a\n *        Bytes to check in\n *\n * @param {Uint8Array|Array} b\n *        Bytes to check for\n *\n * @param {Object} options\n *        options\n *\n * @param {Array|Uint8Array} [offset=0]\n *        offset to use when looking at bytes in a\n *\n * @param {Array|Uint8Array} [mask=[]]\n *        mask to use on bytes before comparison.\n *\n * @return {boolean}\n *         If all bytes in b are inside of a, taking into account\n *         bit masks.\n */\n\nexport var bytesMatch = function bytesMatch(a, b, _temp3) {\n  var _ref3 = _temp3 === void 0 ? {} : _temp3,\n    _ref3$offset = _ref3.offset,\n    offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n    _ref3$mask = _ref3.mask,\n    mask = _ref3$mask === void 0 ? [] : _ref3$mask;\n  a = toUint8(a);\n  b = toUint8(b); // ie 11 does not support uint8 every\n\n  var fn = b.every ? b.every : Array.prototype.every;\n  return b.length && a.length - offset >= b.length &&\n  // ie 11 doesn't support every on uin8\n  fn.call(b, function (bByte, i) {\n    var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];\n    return bByte === aByte;\n  });\n};\nexport var sliceBytes = function sliceBytes(src, start, end) {\n  if (Uint8Array.prototype.slice) {\n    return Uint8Array.prototype.slice.call(src, start, end);\n  }\n  return new Uint8Array(Array.prototype.slice.call(src, start, end));\n};\nexport var reverseBytes = function reverseBytes(src) {\n  if (src.reverse) {\n    return src.reverse();\n  }\n  return Array.prototype.reverse.call(src);\n};","map":{"version":3,"names":["window","repeat","str","len","acc","countBits","x","toString","length","countBytes","Math","ceil","padStart","b","slice","isArrayBufferView","obj","ArrayBuffer","isView","buffer","isTypedArray","toUint8","bytes","Uint8Array","Array","isArray","byteOffset","byteLength","toHexString","i","toBinaryString","BigInt","Number","BYTE_TABLE","ENDIANNESS","a","Uint16Array","IS_BIG_ENDIAN","IS_LITTLE_ENDIAN","bytesToNumber","_temp","_ref","_ref$signed","signed","_ref$le","le","fn","prototype","number","call","total","byte","exponent","abs","max","numberToBytes","_temp2","_ref2","_ref2$le","byteCount","byteIndex","bytesToString","string","String","fromCharCode","apply","decodeURIComponent","escape","e","stringToBytes","stringIsBytes","unescape","encodeURIComponent","view","charCodeAt","concatTypedArrays","_len","arguments","buffers","_key","filter","totalLen","reduce","buf","tempBuffer","offset","forEach","set","bytesMatch","_temp3","_ref3","_ref3$offset","_ref3$mask","mask","every","bByte","aByte","sliceBytes","src","start","end","reverseBytes","reverse"],"sources":["/Users/mihailbaleev/Documents/GitHub/signal-BIT/signal/node_modules/@videojs/vhs-utils/es/byte-helpers.js"],"sourcesContent":["import window from 'global/window'; // const log2 = Math.log2 ? Math.log2 : (x) => (Math.log(x) / Math.log(2));\n\nvar repeat = function repeat(str, len) {\n  var acc = '';\n\n  while (len--) {\n    acc += str;\n  }\n\n  return acc;\n}; // count the number of bits it would take to represent a number\n// we used to do this with log2 but BigInt does not support builtin math\n// Math.ceil(log2(x));\n\n\nexport var countBits = function countBits(x) {\n  return x.toString(2).length;\n}; // count the number of whole bytes it would take to represent a number\n\nexport var countBytes = function countBytes(x) {\n  return Math.ceil(countBits(x) / 8);\n};\nexport var padStart = function padStart(b, len, str) {\n  if (str === void 0) {\n    str = ' ';\n  }\n\n  return (repeat(str, len) + b.toString()).slice(-len);\n};\nexport var isArrayBufferView = function isArrayBufferView(obj) {\n  if (ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(obj);\n  }\n\n  return obj && obj.buffer instanceof ArrayBuffer;\n};\nexport var isTypedArray = function isTypedArray(obj) {\n  return isArrayBufferView(obj);\n};\nexport var toUint8 = function toUint8(bytes) {\n  if (bytes instanceof Uint8Array) {\n    return bytes;\n  }\n\n  if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {\n    // any non-number or NaN leads to empty uint8array\n    // eslint-disable-next-line\n    if (typeof bytes !== 'number' || typeof bytes === 'number' && bytes !== bytes) {\n      bytes = 0;\n    } else {\n      bytes = [bytes];\n    }\n  }\n\n  return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\n};\nexport var toHexString = function toHexString(bytes) {\n  bytes = toUint8(bytes);\n  var str = '';\n\n  for (var i = 0; i < bytes.length; i++) {\n    str += padStart(bytes[i].toString(16), 2, '0');\n  }\n\n  return str;\n};\nexport var toBinaryString = function toBinaryString(bytes) {\n  bytes = toUint8(bytes);\n  var str = '';\n\n  for (var i = 0; i < bytes.length; i++) {\n    str += padStart(bytes[i].toString(2), 8, '0');\n  }\n\n  return str;\n};\nvar BigInt = window.BigInt || Number;\nvar BYTE_TABLE = [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\nexport var ENDIANNESS = function () {\n  var a = new Uint16Array([0xFFCC]);\n  var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n\n  if (b[0] === 0xFF) {\n    return 'big';\n  }\n\n  if (b[0] === 0xCC) {\n    return 'little';\n  }\n\n  return 'unknown';\n}();\nexport var IS_BIG_ENDIAN = ENDIANNESS === 'big';\nexport var IS_LITTLE_ENDIAN = ENDIANNESS === 'little';\nexport var bytesToNumber = function bytesToNumber(bytes, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$signed = _ref.signed,\n      signed = _ref$signed === void 0 ? false : _ref$signed,\n      _ref$le = _ref.le,\n      le = _ref$le === void 0 ? false : _ref$le;\n\n  bytes = toUint8(bytes);\n  var fn = le ? 'reduce' : 'reduceRight';\n  var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];\n  var number = obj.call(bytes, function (total, byte, i) {\n    var exponent = le ? i : Math.abs(i + 1 - bytes.length);\n    return total + BigInt(byte) * BYTE_TABLE[exponent];\n  }, BigInt(0));\n\n  if (signed) {\n    var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);\n    number = BigInt(number);\n\n    if (number > max) {\n      number -= max;\n      number -= max;\n      number -= BigInt(2);\n    }\n  }\n\n  return Number(number);\n};\nexport var numberToBytes = function numberToBytes(number, _temp2) {\n  var _ref2 = _temp2 === void 0 ? {} : _temp2,\n      _ref2$le = _ref2.le,\n      le = _ref2$le === void 0 ? false : _ref2$le;\n\n  // eslint-disable-next-line\n  if (typeof number !== 'bigint' && typeof number !== 'number' || typeof number === 'number' && number !== number) {\n    number = 0;\n  }\n\n  number = BigInt(number);\n  var byteCount = countBytes(number);\n  var bytes = new Uint8Array(new ArrayBuffer(byteCount));\n\n  for (var i = 0; i < byteCount; i++) {\n    var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);\n    bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(0xFF));\n\n    if (number < 0) {\n      bytes[byteIndex] = Math.abs(~bytes[byteIndex]);\n      bytes[byteIndex] -= i === 0 ? 1 : 2;\n    }\n  }\n\n  return bytes;\n};\nexport var bytesToString = function bytesToString(bytes) {\n  if (!bytes) {\n    return '';\n  } // TODO: should toUint8 handle cases where we only have 8 bytes\n  // but report more since this is a Uint16+ Array?\n\n\n  bytes = Array.prototype.slice.call(bytes);\n  var string = String.fromCharCode.apply(null, toUint8(bytes));\n\n  try {\n    return decodeURIComponent(escape(string));\n  } catch (e) {// if decodeURIComponent/escape fails, we are dealing with partial\n    // or full non string data. Just return the potentially garbled string.\n  }\n\n  return string;\n};\nexport var stringToBytes = function stringToBytes(string, stringIsBytes) {\n  if (typeof string !== 'string' && string && typeof string.toString === 'function') {\n    string = string.toString();\n  }\n\n  if (typeof string !== 'string') {\n    return new Uint8Array();\n  } // If the string already is bytes, we don't have to do this\n  // otherwise we do this so that we split multi length characters\n  // into individual bytes\n\n\n  if (!stringIsBytes) {\n    string = unescape(encodeURIComponent(string));\n  }\n\n  var view = new Uint8Array(string.length);\n\n  for (var i = 0; i < string.length; i++) {\n    view[i] = string.charCodeAt(i);\n  }\n\n  return view;\n};\nexport var concatTypedArrays = function concatTypedArrays() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n\n  buffers = buffers.filter(function (b) {\n    return b && (b.byteLength || b.length) && typeof b !== 'string';\n  });\n\n  if (buffers.length <= 1) {\n    // for 0 length we will return empty uint8\n    // for 1 length we return the first uint8\n    return toUint8(buffers[0]);\n  }\n\n  var totalLen = buffers.reduce(function (total, buf, i) {\n    return total + (buf.byteLength || buf.length);\n  }, 0);\n  var tempBuffer = new Uint8Array(totalLen);\n  var offset = 0;\n  buffers.forEach(function (buf) {\n    buf = toUint8(buf);\n    tempBuffer.set(buf, offset);\n    offset += buf.byteLength;\n  });\n  return tempBuffer;\n};\n/**\n * Check if the bytes \"b\" are contained within bytes \"a\".\n *\n * @param {Uint8Array|Array} a\n *        Bytes to check in\n *\n * @param {Uint8Array|Array} b\n *        Bytes to check for\n *\n * @param {Object} options\n *        options\n *\n * @param {Array|Uint8Array} [offset=0]\n *        offset to use when looking at bytes in a\n *\n * @param {Array|Uint8Array} [mask=[]]\n *        mask to use on bytes before comparison.\n *\n * @return {boolean}\n *         If all bytes in b are inside of a, taking into account\n *         bit masks.\n */\n\nexport var bytesMatch = function bytesMatch(a, b, _temp3) {\n  var _ref3 = _temp3 === void 0 ? {} : _temp3,\n      _ref3$offset = _ref3.offset,\n      offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n      _ref3$mask = _ref3.mask,\n      mask = _ref3$mask === void 0 ? [] : _ref3$mask;\n\n  a = toUint8(a);\n  b = toUint8(b); // ie 11 does not support uint8 every\n\n  var fn = b.every ? b.every : Array.prototype.every;\n  return b.length && a.length - offset >= b.length && // ie 11 doesn't support every on uin8\n  fn.call(b, function (bByte, i) {\n    var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];\n    return bByte === aByte;\n  });\n};\nexport var sliceBytes = function sliceBytes(src, start, end) {\n  if (Uint8Array.prototype.slice) {\n    return Uint8Array.prototype.slice.call(src, start, end);\n  }\n\n  return new Uint8Array(Array.prototype.slice.call(src, start, end));\n};\nexport var reverseBytes = function reverseBytes(src) {\n  if (src.reverse) {\n    return src.reverse();\n  }\n\n  return Array.prototype.reverse.call(src);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}