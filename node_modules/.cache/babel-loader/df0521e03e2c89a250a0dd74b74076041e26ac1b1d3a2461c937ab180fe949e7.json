{"ast":null,"code":"import { bytesMatch, toUint8 } from './byte-helpers.js';\nexport var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\nexport var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\nexport var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\n/**\n * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n * Sequence Payload\"\n *\n * @param data {Uint8Array} the bytes of a RBSP from a NAL\n * unit\n * @return {Uint8Array} the RBSP without any Emulation\n * Prevention Bytes\n */\n\nexport var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n  var positions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < bytes.length - 2) {\n    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n      positions.push(i + 2);\n      i++;\n    }\n    i++;\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n  if (positions.length === 0) {\n    return bytes;\n  } // Create a new array to hold the NAL unit data\n\n  var newLength = bytes.length - positions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === positions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      positions.shift();\n    }\n    newData[i] = bytes[sourceIndex];\n  }\n  return newData;\n};\nexport var findNal = function findNal(bytes, dataType, types, nalLimit) {\n  if (nalLimit === void 0) {\n    nalLimit = Infinity;\n  }\n  bytes = toUint8(bytes);\n  types = [].concat(types);\n  var i = 0;\n  var nalStart;\n  var nalsFound = 0; // keep searching until:\n  // we reach the end of bytes\n  // we reach the maximum number of nals they want to seach\n  // NOTE: that we disregard nalLimit when we have found the start\n  // of the nal we want so that we can find the end of the nal we want.\n\n  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n    var nalOffset = void 0;\n    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\n      nalOffset = 4;\n    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\n      nalOffset = 3;\n    } // we are unsynced,\n    // find the next nal unit\n\n    if (!nalOffset) {\n      i++;\n      continue;\n    }\n    nalsFound++;\n    if (nalStart) {\n      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n    }\n    var nalType = void 0;\n    if (dataType === 'h264') {\n      nalType = bytes[i + nalOffset] & 0x1f;\n    } else if (dataType === 'h265') {\n      nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n    }\n    if (types.indexOf(nalType) !== -1) {\n      nalStart = i + nalOffset;\n    } // nal header is 1 length for h264, and 2 for h265\n\n    i += nalOffset + (dataType === 'h264' ? 1 : 2);\n  }\n  return bytes.subarray(0, 0);\n};\nexport var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h264', type, nalLimit);\n};\nexport var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h265', type, nalLimit);\n};","map":{"version":3,"names":["bytesMatch","toUint8","NAL_TYPE_ONE","NAL_TYPE_TWO","EMULATION_PREVENTION","discardEmulationPreventionBytes","bytes","positions","i","length","subarray","push","newLength","newData","Uint8Array","sourceIndex","shift","findNal","dataType","types","nalLimit","Infinity","concat","nalStart","nalsFound","nalOffset","nalType","indexOf","findH264Nal","type","findH265Nal"],"sources":["/Users/mihailbaleev/Documents/GitHub/signal-BIT/signal/node_modules/@videojs/vhs-utils/es/nal-helpers.js"],"sourcesContent":["import { bytesMatch, toUint8 } from './byte-helpers.js';\nexport var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\nexport var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\nexport var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\n/**\n * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n * Sequence Payload\"\n *\n * @param data {Uint8Array} the bytes of a RBSP from a NAL\n * unit\n * @return {Uint8Array} the RBSP without any Emulation\n * Prevention Bytes\n */\n\nexport var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n  var positions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < bytes.length - 2) {\n    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n      positions.push(i + 2);\n      i++;\n    }\n\n    i++;\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (positions.length === 0) {\n    return bytes;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = bytes.length - positions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === positions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      positions.shift();\n    }\n\n    newData[i] = bytes[sourceIndex];\n  }\n\n  return newData;\n};\nexport var findNal = function findNal(bytes, dataType, types, nalLimit) {\n  if (nalLimit === void 0) {\n    nalLimit = Infinity;\n  }\n\n  bytes = toUint8(bytes);\n  types = [].concat(types);\n  var i = 0;\n  var nalStart;\n  var nalsFound = 0; // keep searching until:\n  // we reach the end of bytes\n  // we reach the maximum number of nals they want to seach\n  // NOTE: that we disregard nalLimit when we have found the start\n  // of the nal we want so that we can find the end of the nal we want.\n\n  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n    var nalOffset = void 0;\n\n    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\n      nalOffset = 4;\n    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\n      nalOffset = 3;\n    } // we are unsynced,\n    // find the next nal unit\n\n\n    if (!nalOffset) {\n      i++;\n      continue;\n    }\n\n    nalsFound++;\n\n    if (nalStart) {\n      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n    }\n\n    var nalType = void 0;\n\n    if (dataType === 'h264') {\n      nalType = bytes[i + nalOffset] & 0x1f;\n    } else if (dataType === 'h265') {\n      nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n    }\n\n    if (types.indexOf(nalType) !== -1) {\n      nalStart = i + nalOffset;\n    } // nal header is 1 length for h264, and 2 for h265\n\n\n    i += nalOffset + (dataType === 'h264' ? 1 : 2);\n  }\n\n  return bytes.subarray(0, 0);\n};\nexport var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h264', type, nalLimit);\n};\nexport var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h265', type, nalLimit);\n};"],"mappings":"AAAA,SAASA,UAAU,EAAEC,OAAO,QAAQ,mBAAmB;AACvD,OAAO,IAAIC,YAAY,GAAGD,OAAO,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAC3D,OAAO,IAAIE,YAAY,GAAGF,OAAO,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACrD,OAAO,IAAIG,oBAAoB,GAAGH,OAAO,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAII,+BAA+B,GAAG,SAASA,+BAA+BA,CAACC,KAAK,EAAE;EAC3F,IAAIC,SAAS,GAAG,EAAE;EAClB,IAAIC,CAAC,GAAG,CAAC,CAAC,CAAC;;EAEX,OAAOA,CAAC,GAAGF,KAAK,CAACG,MAAM,GAAG,CAAC,EAAE;IAC3B,IAAIT,UAAU,CAACM,KAAK,CAACI,QAAQ,CAACF,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,EAAEJ,oBAAoB,CAAC,EAAE;MAC9DG,SAAS,CAACI,IAAI,CAACH,CAAC,GAAG,CAAC,CAAC;MACrBA,CAAC,EAAE;IACL;IAEAA,CAAC,EAAE;EACL,CAAC,CAAC;EACF;;EAGA,IAAID,SAAS,CAACE,MAAM,KAAK,CAAC,EAAE;IAC1B,OAAOH,KAAK;EACd,CAAC,CAAC;;EAGF,IAAIM,SAAS,GAAGN,KAAK,CAACG,MAAM,GAAGF,SAAS,CAACE,MAAM;EAC/C,IAAII,OAAO,GAAG,IAAIC,UAAU,CAACF,SAAS,CAAC;EACvC,IAAIG,WAAW,GAAG,CAAC;EAEnB,KAAKP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,SAAS,EAAEG,WAAW,EAAE,EAAEP,CAAC,EAAE,EAAE;IAC7C,IAAIO,WAAW,KAAKR,SAAS,CAAC,CAAC,CAAC,EAAE;MAChC;MACAQ,WAAW,EAAE,CAAC,CAAC;;MAEfR,SAAS,CAACS,KAAK,CAAC,CAAC;IACnB;IAEAH,OAAO,CAACL,CAAC,CAAC,GAAGF,KAAK,CAACS,WAAW,CAAC;EACjC;EAEA,OAAOF,OAAO;AAChB,CAAC;AACD,OAAO,IAAII,OAAO,GAAG,SAASA,OAAOA,CAACX,KAAK,EAAEY,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EACtE,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;IACvBA,QAAQ,GAAGC,QAAQ;EACrB;EAEAf,KAAK,GAAGL,OAAO,CAACK,KAAK,CAAC;EACtBa,KAAK,GAAG,EAAE,CAACG,MAAM,CAACH,KAAK,CAAC;EACxB,IAAIX,CAAC,GAAG,CAAC;EACT,IAAIe,QAAQ;EACZ,IAAIC,SAAS,GAAG,CAAC,CAAC,CAAC;EACnB;EACA;EACA;EACA;;EAEA,OAAOhB,CAAC,GAAGF,KAAK,CAACG,MAAM,KAAKe,SAAS,GAAGJ,QAAQ,IAAIG,QAAQ,CAAC,EAAE;IAC7D,IAAIE,SAAS,GAAG,KAAK,CAAC;IAEtB,IAAIzB,UAAU,CAACM,KAAK,CAACI,QAAQ,CAACF,CAAC,CAAC,EAAEN,YAAY,CAAC,EAAE;MAC/CuB,SAAS,GAAG,CAAC;IACf,CAAC,MAAM,IAAIzB,UAAU,CAACM,KAAK,CAACI,QAAQ,CAACF,CAAC,CAAC,EAAEL,YAAY,CAAC,EAAE;MACtDsB,SAAS,GAAG,CAAC;IACf,CAAC,CAAC;IACF;;IAGA,IAAI,CAACA,SAAS,EAAE;MACdjB,CAAC,EAAE;MACH;IACF;IAEAgB,SAAS,EAAE;IAEX,IAAID,QAAQ,EAAE;MACZ,OAAOlB,+BAA+B,CAACC,KAAK,CAACI,QAAQ,CAACa,QAAQ,EAAEf,CAAC,CAAC,CAAC;IACrE;IAEA,IAAIkB,OAAO,GAAG,KAAK,CAAC;IAEpB,IAAIR,QAAQ,KAAK,MAAM,EAAE;MACvBQ,OAAO,GAAGpB,KAAK,CAACE,CAAC,GAAGiB,SAAS,CAAC,GAAG,IAAI;IACvC,CAAC,MAAM,IAAIP,QAAQ,KAAK,MAAM,EAAE;MAC9BQ,OAAO,GAAGpB,KAAK,CAACE,CAAC,GAAGiB,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI;IAC5C;IAEA,IAAIN,KAAK,CAACQ,OAAO,CAACD,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE;MACjCH,QAAQ,GAAGf,CAAC,GAAGiB,SAAS;IAC1B,CAAC,CAAC;;IAGFjB,CAAC,IAAIiB,SAAS,IAAIP,QAAQ,KAAK,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;EAChD;EAEA,OAAOZ,KAAK,CAACI,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;AAC7B,CAAC;AACD,OAAO,IAAIkB,WAAW,GAAG,SAASA,WAAWA,CAACtB,KAAK,EAAEuB,IAAI,EAAET,QAAQ,EAAE;EACnE,OAAOH,OAAO,CAACX,KAAK,EAAE,MAAM,EAAEuB,IAAI,EAAET,QAAQ,CAAC;AAC/C,CAAC;AACD,OAAO,IAAIU,WAAW,GAAG,SAASA,WAAWA,CAACxB,KAAK,EAAEuB,IAAI,EAAET,QAAQ,EAAE;EACnE,OAAOH,OAAO,CAACX,KAAK,EAAE,MAAM,EAAEuB,IAAI,EAAET,QAAQ,CAAC;AAC/C,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}