{"ast":null,"code":"import { toUint8, bytesToNumber, bytesMatch, bytesToString, numberToBytes, padStart } from './byte-helpers';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js'; // relevant specs for this parser:\n// https://matroska-org.github.io/libebml/specs.html\n// https://www.matroska.org/technical/elements.html\n// https://www.webmproject.org/docs/container/\n\nexport var EBML_TAGS = {\n  EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\n  DocType: toUint8([0x42, 0x82]),\n  Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\n  SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\n  Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\n  Track: toUint8([0xAE]),\n  TrackNumber: toUint8([0xd7]),\n  DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\n  TrackEntry: toUint8([0xAE]),\n  TrackType: toUint8([0x83]),\n  FlagDefault: toUint8([0x88]),\n  CodecID: toUint8([0x86]),\n  CodecPrivate: toUint8([0x63, 0xA2]),\n  VideoTrack: toUint8([0xe0]),\n  AudioTrack: toUint8([0xe1]),\n  // Not used yet, but will be used for live webm/mkv\n  // see https://www.matroska.org/technical/basics.html#block-structure\n  // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n  Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\n  Timestamp: toUint8([0xE7]),\n  TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\n  BlockGroup: toUint8([0xA0]),\n  BlockDuration: toUint8([0x9B]),\n  Block: toUint8([0xA1]),\n  SimpleBlock: toUint8([0xA3])\n};\n/**\n * This is a simple table to determine the length\n * of things in ebml. The length is one based (starts at 1,\n * rather than zero) and for every zero bit before a one bit\n * we add one to length. We also need this table because in some\n * case we have to xor all the length bits from another value.\n */\n\nvar LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\nvar getLength = function getLength(byte) {\n  var len = 1;\n  for (var i = 0; i < LENGTH_TABLE.length; i++) {\n    if (byte & LENGTH_TABLE[i]) {\n      break;\n    }\n    len++;\n  }\n  return len;\n}; // length in ebml is stored in the first 4 to 8 bits\n// of the first byte. 4 for the id length and 8 for the\n// data size length. Length is measured by converting the number to binary\n// then 1 + the number of zeros before a 1 is encountered starting\n// from the left.\n\nvar getvint = function getvint(bytes, offset, removeLength, signed) {\n  if (removeLength === void 0) {\n    removeLength = true;\n  }\n  if (signed === void 0) {\n    signed = false;\n  }\n  var length = getLength(bytes[offset]);\n  var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n  // as they will be modified below to remove the dataSizeLen bits and we do not\n  // want to modify the original data. normally we could just call slice on\n  // uint8array but ie 11 does not support that...\n\n  if (removeLength) {\n    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n    valueBytes[0] ^= LENGTH_TABLE[length - 1];\n  }\n  return {\n    length: length,\n    value: bytesToNumber(valueBytes, {\n      signed: signed\n    }),\n    bytes: valueBytes\n  };\n};\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return path.match(/.{1,2}/g).map(function (p) {\n      return normalizePath(p);\n    });\n  }\n  if (typeof path === 'number') {\n    return numberToBytes(path);\n  }\n  return path;\n};\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\nvar getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n  if (offset >= bytes.length) {\n    return bytes.length;\n  }\n  var innerid = getvint(bytes, offset, false);\n  if (bytesMatch(id.bytes, innerid.bytes)) {\n    return offset;\n  }\n  var dataHeader = getvint(bytes, offset + innerid.length);\n  return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n};\n/**\n * Notes on the EBLM format.\n *\n * EBLM uses \"vints\" tags. Every vint tag contains\n * two parts\n *\n * 1. The length from the first byte. You get this by\n *    converting the byte to binary and counting the zeros\n *    before a 1. Then you add 1 to that. Examples\n *    00011111 = length 4 because there are 3 zeros before a 1.\n *    00100000 = length 3 because there are 2 zeros before a 1.\n *    00000011 = length 7 because there are 6 zeros before a 1.\n *\n * 2. The bits used for length are removed from the first byte\n *    Then all the bytes are merged into a value. NOTE: this\n *    is not the case for id ebml tags as there id includes\n *    length bits.\n *\n */\n\nexport var findEbml = function findEbml(bytes, paths) {\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n  if (!paths.length) {\n    return results;\n  }\n  var i = 0;\n  while (i < bytes.length) {\n    var id = getvint(bytes, i, false);\n    var dataHeader = getvint(bytes, i + id.length);\n    var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n    if (dataHeader.value === 0x7f) {\n      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n      if (dataHeader.value !== bytes.length) {\n        dataHeader.value -= dataStart;\n      }\n    }\n    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n    var data = bytes.subarray(dataStart, dataEnd);\n    if (bytesMatch(paths[0], id.bytes)) {\n      if (paths.length === 1) {\n        // this is the end of the paths and we've found the tag we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next tag inside of the data\n        // of this one\n        results = results.concat(findEbml(data, paths.slice(1)));\n      }\n    }\n    var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n    i += totalLength;\n  }\n  return results;\n}; // see https://www.matroska.org/technical/basics.html#block-structure\n\nexport var decodeBlock = function decodeBlock(block, type, timestampScale, clusterTimestamp) {\n  var duration;\n  if (type === 'group') {\n    duration = findEbml(block, [EBML_TAGS.BlockDuration])[0];\n    if (duration) {\n      duration = bytesToNumber(duration);\n      duration = 1 / timestampScale * duration * timestampScale / 1000;\n    }\n    block = findEbml(block, [EBML_TAGS.Block])[0];\n    type = 'block'; // treat data as a block after this point\n  }\n  var dv = new DataView(block.buffer, block.byteOffset, block.byteLength);\n  var trackNumber = getvint(block, 0);\n  var timestamp = dv.getInt16(trackNumber.length, false);\n  var flags = block[trackNumber.length + 2];\n  var data = block.subarray(trackNumber.length + 3); // pts/dts in seconds\n\n  var ptsdts = 1 / timestampScale * (clusterTimestamp + timestamp) * timestampScale / 1000; // return the frame\n\n  var parsed = {\n    duration: duration,\n    trackNumber: trackNumber.value,\n    keyframe: type === 'simple' && flags >> 7 === 1,\n    invisible: (flags & 0x08) >> 3 === 1,\n    lacing: (flags & 0x06) >> 1,\n    discardable: type === 'simple' && (flags & 0x01) === 1,\n    frames: [],\n    pts: ptsdts,\n    dts: ptsdts,\n    timestamp: timestamp\n  };\n  if (!parsed.lacing) {\n    parsed.frames.push(data);\n    return parsed;\n  }\n  var numberOfFrames = data[0] + 1;\n  var frameSizes = [];\n  var offset = 1; // Fixed\n\n  if (parsed.lacing === 2) {\n    var sizeOfFrame = (data.length - offset) / numberOfFrames;\n    for (var i = 0; i < numberOfFrames; i++) {\n      frameSizes.push(sizeOfFrame);\n    }\n  } // xiph\n\n  if (parsed.lacing === 1) {\n    for (var _i = 0; _i < numberOfFrames - 1; _i++) {\n      var size = 0;\n      do {\n        size += data[offset];\n        offset++;\n      } while (data[offset - 1] === 0xFF);\n      frameSizes.push(size);\n    }\n  } // ebml\n\n  if (parsed.lacing === 3) {\n    // first vint is unsinged\n    // after that vints are singed and\n    // based on a compounding size\n    var _size = 0;\n    for (var _i2 = 0; _i2 < numberOfFrames - 1; _i2++) {\n      var vint = _i2 === 0 ? getvint(data, offset) : getvint(data, offset, true, true);\n      _size += vint.value;\n      frameSizes.push(_size);\n      offset += vint.length;\n    }\n  }\n  frameSizes.forEach(function (size) {\n    parsed.frames.push(data.subarray(offset, offset + size));\n    offset += size;\n  });\n  return parsed;\n}; // VP9 Codec Feature Metadata (CodecPrivate)\n// https://www.webmproject.org/docs/container/\n\nvar parseVp9Private = function parseVp9Private(bytes) {\n  var i = 0;\n  var params = {};\n  while (i < bytes.length) {\n    var id = bytes[i] & 0x7f;\n    var len = bytes[i + 1];\n    var val = void 0;\n    if (len === 1) {\n      val = bytes[i + 2];\n    } else {\n      val = bytes.subarray(i + 2, i + 2 + len);\n    }\n    if (id === 1) {\n      params.profile = val;\n    } else if (id === 2) {\n      params.level = val;\n    } else if (id === 3) {\n      params.bitDepth = val;\n    } else if (id === 4) {\n      params.chromaSubsampling = val;\n    } else {\n      params[id] = val;\n    }\n    i += 2 + len;\n  }\n  return params;\n};\nexport var parseTracks = function parseTracks(bytes) {\n  bytes = toUint8(bytes);\n  var decodedTracks = [];\n  var tracks = findEbml(bytes, [EBML_TAGS.Segment, EBML_TAGS.Tracks, EBML_TAGS.Track]);\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Tracks, EBML_TAGS.Track]);\n  }\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Track]);\n  }\n  if (!tracks.length) {\n    return decodedTracks;\n  }\n  tracks.forEach(function (track) {\n    var trackType = findEbml(track, EBML_TAGS.TrackType)[0];\n    if (!trackType || !trackType.length) {\n      return;\n    } // 1 is video, 2 is audio, 17 is subtitle\n    // other values are unimportant in this context\n\n    if (trackType[0] === 1) {\n      trackType = 'video';\n    } else if (trackType[0] === 2) {\n      trackType = 'audio';\n    } else if (trackType[0] === 17) {\n      trackType = 'subtitle';\n    } else {\n      return;\n    } // todo parse language\n\n    var decodedTrack = {\n      rawCodec: bytesToString(findEbml(track, [EBML_TAGS.CodecID])[0]),\n      type: trackType,\n      codecPrivate: findEbml(track, [EBML_TAGS.CodecPrivate])[0],\n      number: bytesToNumber(findEbml(track, [EBML_TAGS.TrackNumber])[0]),\n      defaultDuration: bytesToNumber(findEbml(track, [EBML_TAGS.DefaultDuration])[0]),\n      default: findEbml(track, [EBML_TAGS.FlagDefault])[0],\n      rawData: track\n    };\n    var codec = '';\n    if (/V_MPEG4\\/ISO\\/AVC/.test(decodedTrack.rawCodec)) {\n      codec = \"avc1.\" + getAvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEGH\\/ISO\\/HEVC/.test(decodedTrack.rawCodec)) {\n      codec = \"hev1.\" + getHvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEG4\\/ISO\\/ASP/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4v.20.' + decodedTrack.codecPrivate[4].toString();\n      } else {\n        codec = 'mp4v.20.9';\n      }\n    } else if (/^V_THEORA/.test(decodedTrack.rawCodec)) {\n      codec = 'theora';\n    } else if (/^V_VP8/.test(decodedTrack.rawCodec)) {\n      codec = 'vp8';\n    } else if (/^V_VP9/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        var _parseVp9Private = parseVp9Private(decodedTrack.codecPrivate),\n          profile = _parseVp9Private.profile,\n          level = _parseVp9Private.level,\n          bitDepth = _parseVp9Private.bitDepth,\n          chromaSubsampling = _parseVp9Private.chromaSubsampling;\n        codec = 'vp09.';\n        codec += padStart(profile, 2, '0') + \".\";\n        codec += padStart(level, 2, '0') + \".\";\n        codec += padStart(bitDepth, 2, '0') + \".\";\n        codec += \"\" + padStart(chromaSubsampling, 2, '0'); // Video -> Colour -> Ebml name\n\n        var matrixCoefficients = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB1]])[0] || [];\n        var videoFullRangeFlag = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB9]])[0] || [];\n        var transferCharacteristics = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBA]])[0] || [];\n        var colourPrimaries = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBB]])[0] || []; // if we find any optional codec parameter specify them all.\n\n        if (matrixCoefficients.length || videoFullRangeFlag.length || transferCharacteristics.length || colourPrimaries.length) {\n          codec += \".\" + padStart(colourPrimaries[0], 2, '0');\n          codec += \".\" + padStart(transferCharacteristics[0], 2, '0');\n          codec += \".\" + padStart(matrixCoefficients[0], 2, '0');\n          codec += \".\" + padStart(videoFullRangeFlag[0], 2, '0');\n        }\n      } else {\n        codec = 'vp9';\n      }\n    } else if (/^V_AV1/.test(decodedTrack.rawCodec)) {\n      codec = \"av01.\" + getAv1Codec(decodedTrack.codecPrivate);\n    } else if (/A_ALAC/.test(decodedTrack.rawCodec)) {\n      codec = 'alac';\n    } else if (/A_MPEG\\/L2/.test(decodedTrack.rawCodec)) {\n      codec = 'mp2';\n    } else if (/A_MPEG\\/L3/.test(decodedTrack.rawCodec)) {\n      codec = 'mp3';\n    } else if (/^A_AAC/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4a.40.' + (decodedTrack.codecPrivate[0] >>> 3).toString();\n      } else {\n        codec = 'mp4a.40.2';\n      }\n    } else if (/^A_AC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ac-3';\n    } else if (/^A_PCM/.test(decodedTrack.rawCodec)) {\n      codec = 'pcm';\n    } else if (/^A_MS\\/ACM/.test(decodedTrack.rawCodec)) {\n      codec = 'speex';\n    } else if (/^A_EAC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ec-3';\n    } else if (/^A_VORBIS/.test(decodedTrack.rawCodec)) {\n      codec = 'vorbis';\n    } else if (/^A_FLAC/.test(decodedTrack.rawCodec)) {\n      codec = 'flac';\n    } else if (/^A_OPUS/.test(decodedTrack.rawCodec)) {\n      codec = 'opus';\n    }\n    decodedTrack.codec = codec;\n    decodedTracks.push(decodedTrack);\n  });\n  return decodedTracks.sort(function (a, b) {\n    return a.number - b.number;\n  });\n};\nexport var parseData = function parseData(data, tracks) {\n  var allBlocks = [];\n  var segment = findEbml(data, [EBML_TAGS.Segment])[0];\n  var timestampScale = findEbml(segment, [EBML_TAGS.SegmentInfo, EBML_TAGS.TimestampScale])[0]; // in nanoseconds, defaults to 1ms\n\n  if (timestampScale && timestampScale.length) {\n    timestampScale = bytesToNumber(timestampScale);\n  } else {\n    timestampScale = 1000000;\n  }\n  var clusters = findEbml(segment, [EBML_TAGS.Cluster]);\n  if (!tracks) {\n    tracks = parseTracks(segment);\n  }\n  clusters.forEach(function (cluster, ci) {\n    var simpleBlocks = findEbml(cluster, [EBML_TAGS.SimpleBlock]).map(function (b) {\n      return {\n        type: 'simple',\n        data: b\n      };\n    });\n    var blockGroups = findEbml(cluster, [EBML_TAGS.BlockGroup]).map(function (b) {\n      return {\n        type: 'group',\n        data: b\n      };\n    });\n    var timestamp = findEbml(cluster, [EBML_TAGS.Timestamp])[0] || 0;\n    if (timestamp && timestamp.length) {\n      timestamp = bytesToNumber(timestamp);\n    } // get all blocks then sort them into the correct order\n\n    var blocks = simpleBlocks.concat(blockGroups).sort(function (a, b) {\n      return a.data.byteOffset - b.data.byteOffset;\n    });\n    blocks.forEach(function (block, bi) {\n      var decoded = decodeBlock(block.data, block.type, timestampScale, timestamp);\n      allBlocks.push(decoded);\n    });\n  });\n  return {\n    tracks: tracks,\n    blocks: allBlocks\n  };\n};","map":{"version":3,"names":["toUint8","bytesToNumber","bytesMatch","bytesToString","numberToBytes","padStart","getAvcCodec","getHvcCodec","getAv1Codec","EBML_TAGS","EBML","DocType","Segment","SegmentInfo","Tracks","Track","TrackNumber","DefaultDuration","TrackEntry","TrackType","FlagDefault","CodecID","CodecPrivate","VideoTrack","AudioTrack","Cluster","Timestamp","TimestampScale","BlockGroup","BlockDuration","Block","SimpleBlock","LENGTH_TABLE","getLength","byte","len","i","length","getvint","bytes","offset","removeLength","signed","valueBytes","subarray","Array","prototype","slice","call","value","normalizePath","path","match","map","p","normalizePaths","paths","isArray","getInfinityDataSize","id","innerid","dataHeader","findEbml","results","dataStart","dataEnd","data","push","concat","totalLength","decodeBlock","block","type","timestampScale","clusterTimestamp","duration","dv","DataView","buffer","byteOffset","byteLength","trackNumber","timestamp","getInt16","flags","ptsdts","parsed","keyframe","invisible","lacing","discardable","frames","pts","dts","numberOfFrames","frameSizes","sizeOfFrame","_i","size","_size","_i2","vint","forEach","parseVp9Private","params","val","profile","level","bitDepth","chromaSubsampling","parseTracks","decodedTracks","tracks","track","trackType","decodedTrack","rawCodec","codecPrivate","number","defaultDuration","default","rawData","codec","test","toString","_parseVp9Private","matrixCoefficients","videoFullRangeFlag","transferCharacteristics","colourPrimaries","sort","a","b","parseData","allBlocks","segment","clusters","cluster","ci","simpleBlocks","blockGroups","blocks","bi","decoded"],"sources":["/Users/mihailbaleev/Documents/GitHub/signal-BIT/signal/node_modules/@videojs/vhs-utils/es/ebml-helpers.js"],"sourcesContent":["import { toUint8, bytesToNumber, bytesMatch, bytesToString, numberToBytes, padStart } from './byte-helpers';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js'; // relevant specs for this parser:\n// https://matroska-org.github.io/libebml/specs.html\n// https://www.matroska.org/technical/elements.html\n// https://www.webmproject.org/docs/container/\n\nexport var EBML_TAGS = {\n  EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\n  DocType: toUint8([0x42, 0x82]),\n  Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\n  SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\n  Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\n  Track: toUint8([0xAE]),\n  TrackNumber: toUint8([0xd7]),\n  DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\n  TrackEntry: toUint8([0xAE]),\n  TrackType: toUint8([0x83]),\n  FlagDefault: toUint8([0x88]),\n  CodecID: toUint8([0x86]),\n  CodecPrivate: toUint8([0x63, 0xA2]),\n  VideoTrack: toUint8([0xe0]),\n  AudioTrack: toUint8([0xe1]),\n  // Not used yet, but will be used for live webm/mkv\n  // see https://www.matroska.org/technical/basics.html#block-structure\n  // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n  Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\n  Timestamp: toUint8([0xE7]),\n  TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\n  BlockGroup: toUint8([0xA0]),\n  BlockDuration: toUint8([0x9B]),\n  Block: toUint8([0xA1]),\n  SimpleBlock: toUint8([0xA3])\n};\n/**\n * This is a simple table to determine the length\n * of things in ebml. The length is one based (starts at 1,\n * rather than zero) and for every zero bit before a one bit\n * we add one to length. We also need this table because in some\n * case we have to xor all the length bits from another value.\n */\n\nvar LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n\nvar getLength = function getLength(byte) {\n  var len = 1;\n\n  for (var i = 0; i < LENGTH_TABLE.length; i++) {\n    if (byte & LENGTH_TABLE[i]) {\n      break;\n    }\n\n    len++;\n  }\n\n  return len;\n}; // length in ebml is stored in the first 4 to 8 bits\n// of the first byte. 4 for the id length and 8 for the\n// data size length. Length is measured by converting the number to binary\n// then 1 + the number of zeros before a 1 is encountered starting\n// from the left.\n\n\nvar getvint = function getvint(bytes, offset, removeLength, signed) {\n  if (removeLength === void 0) {\n    removeLength = true;\n  }\n\n  if (signed === void 0) {\n    signed = false;\n  }\n\n  var length = getLength(bytes[offset]);\n  var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n  // as they will be modified below to remove the dataSizeLen bits and we do not\n  // want to modify the original data. normally we could just call slice on\n  // uint8array but ie 11 does not support that...\n\n  if (removeLength) {\n    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n    valueBytes[0] ^= LENGTH_TABLE[length - 1];\n  }\n\n  return {\n    length: length,\n    value: bytesToNumber(valueBytes, {\n      signed: signed\n    }),\n    bytes: valueBytes\n  };\n};\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return path.match(/.{1,2}/g).map(function (p) {\n      return normalizePath(p);\n    });\n  }\n\n  if (typeof path === 'number') {\n    return numberToBytes(path);\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n  if (offset >= bytes.length) {\n    return bytes.length;\n  }\n\n  var innerid = getvint(bytes, offset, false);\n\n  if (bytesMatch(id.bytes, innerid.bytes)) {\n    return offset;\n  }\n\n  var dataHeader = getvint(bytes, offset + innerid.length);\n  return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n};\n/**\n * Notes on the EBLM format.\n *\n * EBLM uses \"vints\" tags. Every vint tag contains\n * two parts\n *\n * 1. The length from the first byte. You get this by\n *    converting the byte to binary and counting the zeros\n *    before a 1. Then you add 1 to that. Examples\n *    00011111 = length 4 because there are 3 zeros before a 1.\n *    00100000 = length 3 because there are 2 zeros before a 1.\n *    00000011 = length 7 because there are 6 zeros before a 1.\n *\n * 2. The bits used for length are removed from the first byte\n *    Then all the bytes are merged into a value. NOTE: this\n *    is not the case for id ebml tags as there id includes\n *    length bits.\n *\n */\n\n\nexport var findEbml = function findEbml(bytes, paths) {\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var id = getvint(bytes, i, false);\n    var dataHeader = getvint(bytes, i + id.length);\n    var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n    if (dataHeader.value === 0x7f) {\n      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n\n      if (dataHeader.value !== bytes.length) {\n        dataHeader.value -= dataStart;\n      }\n    }\n\n    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n    var data = bytes.subarray(dataStart, dataEnd);\n\n    if (bytesMatch(paths[0], id.bytes)) {\n      if (paths.length === 1) {\n        // this is the end of the paths and we've found the tag we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next tag inside of the data\n        // of this one\n        results = results.concat(findEbml(data, paths.slice(1)));\n      }\n    }\n\n    var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n    i += totalLength;\n  }\n\n  return results;\n}; // see https://www.matroska.org/technical/basics.html#block-structure\n\nexport var decodeBlock = function decodeBlock(block, type, timestampScale, clusterTimestamp) {\n  var duration;\n\n  if (type === 'group') {\n    duration = findEbml(block, [EBML_TAGS.BlockDuration])[0];\n\n    if (duration) {\n      duration = bytesToNumber(duration);\n      duration = 1 / timestampScale * duration * timestampScale / 1000;\n    }\n\n    block = findEbml(block, [EBML_TAGS.Block])[0];\n    type = 'block'; // treat data as a block after this point\n  }\n\n  var dv = new DataView(block.buffer, block.byteOffset, block.byteLength);\n  var trackNumber = getvint(block, 0);\n  var timestamp = dv.getInt16(trackNumber.length, false);\n  var flags = block[trackNumber.length + 2];\n  var data = block.subarray(trackNumber.length + 3); // pts/dts in seconds\n\n  var ptsdts = 1 / timestampScale * (clusterTimestamp + timestamp) * timestampScale / 1000; // return the frame\n\n  var parsed = {\n    duration: duration,\n    trackNumber: trackNumber.value,\n    keyframe: type === 'simple' && flags >> 7 === 1,\n    invisible: (flags & 0x08) >> 3 === 1,\n    lacing: (flags & 0x06) >> 1,\n    discardable: type === 'simple' && (flags & 0x01) === 1,\n    frames: [],\n    pts: ptsdts,\n    dts: ptsdts,\n    timestamp: timestamp\n  };\n\n  if (!parsed.lacing) {\n    parsed.frames.push(data);\n    return parsed;\n  }\n\n  var numberOfFrames = data[0] + 1;\n  var frameSizes = [];\n  var offset = 1; // Fixed\n\n  if (parsed.lacing === 2) {\n    var sizeOfFrame = (data.length - offset) / numberOfFrames;\n\n    for (var i = 0; i < numberOfFrames; i++) {\n      frameSizes.push(sizeOfFrame);\n    }\n  } // xiph\n\n\n  if (parsed.lacing === 1) {\n    for (var _i = 0; _i < numberOfFrames - 1; _i++) {\n      var size = 0;\n\n      do {\n        size += data[offset];\n        offset++;\n      } while (data[offset - 1] === 0xFF);\n\n      frameSizes.push(size);\n    }\n  } // ebml\n\n\n  if (parsed.lacing === 3) {\n    // first vint is unsinged\n    // after that vints are singed and\n    // based on a compounding size\n    var _size = 0;\n\n    for (var _i2 = 0; _i2 < numberOfFrames - 1; _i2++) {\n      var vint = _i2 === 0 ? getvint(data, offset) : getvint(data, offset, true, true);\n      _size += vint.value;\n      frameSizes.push(_size);\n      offset += vint.length;\n    }\n  }\n\n  frameSizes.forEach(function (size) {\n    parsed.frames.push(data.subarray(offset, offset + size));\n    offset += size;\n  });\n  return parsed;\n}; // VP9 Codec Feature Metadata (CodecPrivate)\n// https://www.webmproject.org/docs/container/\n\nvar parseVp9Private = function parseVp9Private(bytes) {\n  var i = 0;\n  var params = {};\n\n  while (i < bytes.length) {\n    var id = bytes[i] & 0x7f;\n    var len = bytes[i + 1];\n    var val = void 0;\n\n    if (len === 1) {\n      val = bytes[i + 2];\n    } else {\n      val = bytes.subarray(i + 2, i + 2 + len);\n    }\n\n    if (id === 1) {\n      params.profile = val;\n    } else if (id === 2) {\n      params.level = val;\n    } else if (id === 3) {\n      params.bitDepth = val;\n    } else if (id === 4) {\n      params.chromaSubsampling = val;\n    } else {\n      params[id] = val;\n    }\n\n    i += 2 + len;\n  }\n\n  return params;\n};\n\nexport var parseTracks = function parseTracks(bytes) {\n  bytes = toUint8(bytes);\n  var decodedTracks = [];\n  var tracks = findEbml(bytes, [EBML_TAGS.Segment, EBML_TAGS.Tracks, EBML_TAGS.Track]);\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Tracks, EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    return decodedTracks;\n  }\n\n  tracks.forEach(function (track) {\n    var trackType = findEbml(track, EBML_TAGS.TrackType)[0];\n\n    if (!trackType || !trackType.length) {\n      return;\n    } // 1 is video, 2 is audio, 17 is subtitle\n    // other values are unimportant in this context\n\n\n    if (trackType[0] === 1) {\n      trackType = 'video';\n    } else if (trackType[0] === 2) {\n      trackType = 'audio';\n    } else if (trackType[0] === 17) {\n      trackType = 'subtitle';\n    } else {\n      return;\n    } // todo parse language\n\n\n    var decodedTrack = {\n      rawCodec: bytesToString(findEbml(track, [EBML_TAGS.CodecID])[0]),\n      type: trackType,\n      codecPrivate: findEbml(track, [EBML_TAGS.CodecPrivate])[0],\n      number: bytesToNumber(findEbml(track, [EBML_TAGS.TrackNumber])[0]),\n      defaultDuration: bytesToNumber(findEbml(track, [EBML_TAGS.DefaultDuration])[0]),\n      default: findEbml(track, [EBML_TAGS.FlagDefault])[0],\n      rawData: track\n    };\n    var codec = '';\n\n    if (/V_MPEG4\\/ISO\\/AVC/.test(decodedTrack.rawCodec)) {\n      codec = \"avc1.\" + getAvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEGH\\/ISO\\/HEVC/.test(decodedTrack.rawCodec)) {\n      codec = \"hev1.\" + getHvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEG4\\/ISO\\/ASP/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4v.20.' + decodedTrack.codecPrivate[4].toString();\n      } else {\n        codec = 'mp4v.20.9';\n      }\n    } else if (/^V_THEORA/.test(decodedTrack.rawCodec)) {\n      codec = 'theora';\n    } else if (/^V_VP8/.test(decodedTrack.rawCodec)) {\n      codec = 'vp8';\n    } else if (/^V_VP9/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        var _parseVp9Private = parseVp9Private(decodedTrack.codecPrivate),\n            profile = _parseVp9Private.profile,\n            level = _parseVp9Private.level,\n            bitDepth = _parseVp9Private.bitDepth,\n            chromaSubsampling = _parseVp9Private.chromaSubsampling;\n\n        codec = 'vp09.';\n        codec += padStart(profile, 2, '0') + \".\";\n        codec += padStart(level, 2, '0') + \".\";\n        codec += padStart(bitDepth, 2, '0') + \".\";\n        codec += \"\" + padStart(chromaSubsampling, 2, '0'); // Video -> Colour -> Ebml name\n\n        var matrixCoefficients = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB1]])[0] || [];\n        var videoFullRangeFlag = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB9]])[0] || [];\n        var transferCharacteristics = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBA]])[0] || [];\n        var colourPrimaries = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBB]])[0] || []; // if we find any optional codec parameter specify them all.\n\n        if (matrixCoefficients.length || videoFullRangeFlag.length || transferCharacteristics.length || colourPrimaries.length) {\n          codec += \".\" + padStart(colourPrimaries[0], 2, '0');\n          codec += \".\" + padStart(transferCharacteristics[0], 2, '0');\n          codec += \".\" + padStart(matrixCoefficients[0], 2, '0');\n          codec += \".\" + padStart(videoFullRangeFlag[0], 2, '0');\n        }\n      } else {\n        codec = 'vp9';\n      }\n    } else if (/^V_AV1/.test(decodedTrack.rawCodec)) {\n      codec = \"av01.\" + getAv1Codec(decodedTrack.codecPrivate);\n    } else if (/A_ALAC/.test(decodedTrack.rawCodec)) {\n      codec = 'alac';\n    } else if (/A_MPEG\\/L2/.test(decodedTrack.rawCodec)) {\n      codec = 'mp2';\n    } else if (/A_MPEG\\/L3/.test(decodedTrack.rawCodec)) {\n      codec = 'mp3';\n    } else if (/^A_AAC/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4a.40.' + (decodedTrack.codecPrivate[0] >>> 3).toString();\n      } else {\n        codec = 'mp4a.40.2';\n      }\n    } else if (/^A_AC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ac-3';\n    } else if (/^A_PCM/.test(decodedTrack.rawCodec)) {\n      codec = 'pcm';\n    } else if (/^A_MS\\/ACM/.test(decodedTrack.rawCodec)) {\n      codec = 'speex';\n    } else if (/^A_EAC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ec-3';\n    } else if (/^A_VORBIS/.test(decodedTrack.rawCodec)) {\n      codec = 'vorbis';\n    } else if (/^A_FLAC/.test(decodedTrack.rawCodec)) {\n      codec = 'flac';\n    } else if (/^A_OPUS/.test(decodedTrack.rawCodec)) {\n      codec = 'opus';\n    }\n\n    decodedTrack.codec = codec;\n    decodedTracks.push(decodedTrack);\n  });\n  return decodedTracks.sort(function (a, b) {\n    return a.number - b.number;\n  });\n};\nexport var parseData = function parseData(data, tracks) {\n  var allBlocks = [];\n  var segment = findEbml(data, [EBML_TAGS.Segment])[0];\n  var timestampScale = findEbml(segment, [EBML_TAGS.SegmentInfo, EBML_TAGS.TimestampScale])[0]; // in nanoseconds, defaults to 1ms\n\n  if (timestampScale && timestampScale.length) {\n    timestampScale = bytesToNumber(timestampScale);\n  } else {\n    timestampScale = 1000000;\n  }\n\n  var clusters = findEbml(segment, [EBML_TAGS.Cluster]);\n\n  if (!tracks) {\n    tracks = parseTracks(segment);\n  }\n\n  clusters.forEach(function (cluster, ci) {\n    var simpleBlocks = findEbml(cluster, [EBML_TAGS.SimpleBlock]).map(function (b) {\n      return {\n        type: 'simple',\n        data: b\n      };\n    });\n    var blockGroups = findEbml(cluster, [EBML_TAGS.BlockGroup]).map(function (b) {\n      return {\n        type: 'group',\n        data: b\n      };\n    });\n    var timestamp = findEbml(cluster, [EBML_TAGS.Timestamp])[0] || 0;\n\n    if (timestamp && timestamp.length) {\n      timestamp = bytesToNumber(timestamp);\n    } // get all blocks then sort them into the correct order\n\n\n    var blocks = simpleBlocks.concat(blockGroups).sort(function (a, b) {\n      return a.data.byteOffset - b.data.byteOffset;\n    });\n    blocks.forEach(function (block, bi) {\n      var decoded = decodeBlock(block.data, block.type, timestampScale, timestamp);\n      allBlocks.push(decoded);\n    });\n  });\n  return {\n    tracks: tracks,\n    blocks: allBlocks\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}